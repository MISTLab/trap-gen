# Introduction #

After completing the description of the processor using TRAP's APIs, the processor can be generated by
executing the file (among the ones composing the processor description) containg the call to the
`write` method of the class `Processor`.

After executing this command the C++ for the processor get generated: you  will find a _processor_
sub-folder under the current folder; inside this folder there are folders _funcLT_, _funcAT_, and _accAT_
(one for each available processor type if all of them are generated). Inside the _funcLT_ folder
there is a _test_ subfolder (only in case SystemC is not used) which contains the tests for the single
instructions (an executable file called _test_ is created for the execution of the tests).

The build systems, as the build system of TRAP itself, is based on _waf_ (http://code.google.com/p/waf);
details instructions on how to build the simulators using waf are contained in the Setup section of this
wiki.

# TRAP Runtime #

The C++ code composing the generated simulators is partly based on autogenerated code and partly
from the pre-built code, called _runtime_. This code is contained in folder `trap/runtime`.

In particular we can identify the following parts:
  * _debugger_: ...
  * _osEmulator_: ...
  * _bfdFrontend_: ...
  * _loader_: ...
  * _memories_: ...

## Operating System Emulator ##

## GDB Debugger ##

## Applcation Loader ##

# Functional Simulator #

The code of the functional simulator is contained in the following files:
  1. _alias.cpp, alias.hpp_: ...
  1. _decoder.cpp, decoder.hpp_: ...
  1. _externalPorts.cpp, externalPorts.hpp_: ...
  1. _instructions.cpp, instructions.hpp_: ...
  1. _interface.cpp, interface.hpp_: ...
  1. _irqPorts.cpp, irqPorts.hpp_: ...
  1. _main.cpp_: ...
  1. _memory.cpp, memory.hpp_: ...
  1. _processor.cpp, processor.hpp_: ...
  1. _registers.cpp, registers.hpp_: ...

We now see more in detail the most complex parts of the code, which are the description of the instruction set behavior
and of the processor architecture.

## Instruction Set Description ##

The instruction set architecture is composed of a hierachy of classes; the base class of all the instructions
is called `Instruction`: it contains a references to all the archtiectural elements of the processor
(i.e. register, banks, aliases, memories, constant values, etc.). It also contains the implementation
of the methods which are available to all the instructions, which are `flush`, `stall`, `annull`,
`getMnemonic` (to get the string representing the disassembly of the current instruction),
`getInstructionName` (to get the name of the current instruction), and the implementation of all the
_HelperMethods_ declared in the ISA description files.
Other methods which are declared in the `Instruction` class, but whose implementation is provided by
each different instruction are:
  1. `behavior`: it contains the actual instruction behavior, as described by the C++ code of the instruction; the code for all the different stages and the calls to the _HelperBehaviors_ are inserted in this method.
  1. `replicate`: creates a copy of this instruction and returns it.
  1. `setParams`: given a bitstring, it extract the different instruction elements as specified by the particular format of the instruction.

## Processor Description ##

The processor description is contained inside the `Processor` class. The most important members of this class are:
  * ....

The architectural elements (registers, memory ports, local memories, aliases, etc.) are all attribute members
of the `Processor` class.

## Test ##

The test of the decoder and of the instruction set behavior are located into folder `funcLT/tests`; note that the
tests are created only for the functional simulator and if SystemC is not used in the generated simulator.
The tests are based on the _boost::test_ library and they composed of three units:
  1. _main.cpp_: main file driving the tests; it simply instantiates the tests and runs them.
  1. _isaTests.cpp_: tests of the instruction set; it contains all the tests specified by the developer to test the correct behavior of each instruction of the instruction set; for more details on how to write those tests look at the HowTo wiki page.
  1. _decoderTests.cpp_: tests of the decoder; at processor creation we pick up random bit strings exercising each instruction (i.e. the variable parts of each instruction are randomly chosen, the parts that identify each instruction of course are not) and we verify that the decoder is able to correctly decode them.

Running the tests is simple: just run the _tests_ executable found under the `_build_/default/funcLT/tests` folder.

## Command line parameters ##

The executable file implementing the functional simulator has the following command line parameters:
  1. _help_: prints the available command line parameters together with a brief explanation on how to use them.
  1. _debugger_: enables the debugger, for the debugging of the applications running on the simulator; the debugger simply consists of a GDB stub. In order to use it open GDB (of course the one relative to the architecture being simulated, if we are simulating an arm processor, we need to open the GDB debugger for that architecture), open the application being simulated and connect to the GDB stub as a socket remote host using GDB command `target remote localhost:1500` (since the GDB Stub is waiting for connections on port 1500). Then you can normally debug the application as you would do using a standard GDB debugger; only note that, as normally happens when connecting to a remote target, you start execution with the `cont` command and not with `run`.
  1. _application_: application with has to be simualted on the simulator; of course this application has to be compiled with a compiler for the architecture being simulated. Some cross-compiler are provided at page http://home.dei.polimi.it/fossati/downloads.html; note when using these cross-compilers, the -specs=osemu.specs command line option have to be passed to GCC.
  1. _frequency_: this option is available only if the generated processor model is based on SystemC

# Cycle-accurate Simulator #